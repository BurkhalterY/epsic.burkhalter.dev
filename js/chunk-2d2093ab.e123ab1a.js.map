{"version":3,"sources":["webpack:///./src/views/bin/Gray.vue","webpack:///./src/views/bin/Gray.vue?0ffc"],"names":["name","__exports__","render"],"mappings":"4tFAEE,G,gDADD,eAmEM,cAIS,OACdA,KAAM,Q,qBCpER,MAAMC,EAA2B,IAAgB,EAAQ,CAAC,CAAC,SAASC,KAErD","file":"js/chunk-2d2093ab.e123ab1a.js","sourcesContent":["<template>\n\t<div>\n\t\t<h1>Code Gray</h1>\n\t\t<p>Le code de Gray, également appelé code Gray ou code binaire réfléchi, est un type de codage binaire permettant de ne modifier qu'un seul bit à la fois quand un nombre est augmenté d'une unité.</p>\n\t\t<table>\n\t\t\t<tr><th>Décimal&nbsp;</th><th>Binaire pur&nbsp;</th><th>Code Gray</th></tr>\n\t\t\t<tr><td>0</td><td>0000</td><td>0000</td></tr>\n\t\t\t<tr><td>1</td><td>0001</td><td>0001</td></tr>\n\t\t\t<tr><td>2</td><td>0010</td><td>0011</td></tr>\n\t\t\t<tr><td>3</td><td>0011</td><td>0010</td></tr>\n\t\t\t<tr><td>4</td><td>0100</td><td>0110</td></tr>\n\t\t\t<tr><td>5</td><td>0101</td><td>0111</td></tr>\n\t\t\t<tr><td>6</td><td>0110</td><td>0101</td></tr>\n\t\t\t<tr><td>7</td><td>0111</td><td>0100</td></tr>\n\t\t\t<tr><td>8</td><td>1000</td><td>1100</td></tr>\n\t\t\t<tr><td>9</td><td>1001</td><td>1101</td></tr>\n\t\t\t<tr><td>10</td><td>1010</td><td>1111</td></tr>\n\t\t\t<tr><td>11</td><td>1011</td><td>1110</td></tr>\n\t\t\t<tr><td>12</td><td>1100</td><td>1010</td></tr>\n\t\t\t<tr><td>13</td><td>1101</td><td>1011</td></tr>\n\t\t\t<tr><td>14</td><td>1110</td><td>1001</td></tr>\n\t\t\t<tr><td>15</td><td>1111</td><td>1000</td></tr>\n\t\t</table>\n\t\t<br>\n\n\t\t<h3>Conversion binaire à Gray</h3>\n\t\t<ul>\n\t\t\t<li>Garder le MSB</li>\n\t\t\t<li>Comparer les bits 2 à 2</li>\n\t\t\t<ul>\n\t\t\t\t<li>Si les 2 bits sont les mêmes : écrire 0</li>\n\t\t\t\t<li>Si les 2 bits sont différents : écrire 1</li>\n\t\t\t</ul>\n\t\t</ul>\n\t\t<br>\n\t\t<p>Exemple : 1011<sub>2</sub></p>\n\t\t<ul>\n\t\t\t<li>On garde le MSB : 1...</li>\n\t\t\t<li>On compare les 2 premiers bits : <strong>10</strong>11</li>\n\t\t\t<li>Ils sont différents donc on écrit 1 → 11...</li>\n\t\t\t<li>On compare le bit précèdent avec le bit suivant : 1<strong>01</strong>1</li>\n\t\t\t<li>Ils sont différents donc on écrit 1 → 111...</li>\n\t\t\t<li>On compare le bit précèdent avec le bit suivant : 10<strong>11</strong></li>\n\t\t\t<li>Ils sont égaux donc on écrit 0 → 1110</li>\n\t\t\t<li>1011<sub>2</sub> = 1110<sub>Gray</sub></li>\n\t\t</ul>\n\n\t\t<h3>Conversion Gray à binaire</h3>\n\t\t<ul>\n\t\t\t<li>Garder le MSB</li>\n\t\t\t<li>Comparer le bit qui vient d'être écrit avec le suivant</li>\n\t\t\t<ul>\n\t\t\t\t<li>Si les 2 bits sont les mêmes : écrire 0</li>\n\t\t\t\t<li>Si les 2 bits sont différents : écrire 1</li>\n\t\t\t</ul>\n\t\t</ul>\n\t\t<br>\n\t\t<p>Exemple : 1110<sub>Gray</sub></p>\n\t\t<ul>\n\t\t\t<li>On garde le MSB : 1...</li>\n\t\t\t<li>On compare le bit que l'on vient d'écrire avec le prochain : <strong>1</strong> et 1<strong>1</strong>10</li>\n\t\t\t<li>Ils sont égaux donc on écrit 0 → 10...</li>\n\t\t\t<li>On compare le bit que l'on vient d'écrire avec le prochain : 1<strong>0</strong> et 11<strong>1</strong>0</li>\n\t\t\t<li>Ils sont différents donc on écrit 1 → 101...</li>\n\t\t\t<li>On compare le bit que l'on vient d'écrire avec le prochain : 10<strong>1</strong> et 111<strong>0</strong></li>\n\t\t\t<li>Ils sont différents donc on écrit 1 → 1011</li>\n\t\t\t<li>1110<sub>Gray</sub> = 1011<sub>2</sub></li>\n\t\t</ul>\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\tname: 'Gray',\n\t}\n</script>\n","import { render } from \"./Gray.vue?vue&type=template&id=3d62a7a4\"\nimport script from \"./Gray.vue?vue&type=script&lang=js\"\nexport * from \"./Gray.vue?vue&type=script&lang=js\"\n\nimport exportComponent from \"/home/runner/work/epsic.burkhalter.dev/epsic.burkhalter.dev/node_modules/@vue/cli-service/node_modules/vue-loader-v16/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__"],"sourceRoot":""}