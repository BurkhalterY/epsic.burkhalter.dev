import{_ as n,o as s,c as r,a as t,F as d,b as i,s as l,g as o,e as v,t as u,k as p,p as m,m as b}from"./index-1bfe471e.js";const g={},c=e=>(m("data-v-2450ac13"),e=e(),b(),e),_=l('<h2 data-v-2450ac13>Convertir un nombre réel en binaire.</h2><p data-v-2450ac13> Pour la partie entière, garder le même principe. Puis prendre la partie après la virgule. </p><p class="ml-5" data-v-2450ac13>6,625 → 0,625</p><p data-v-2450ac13> Il faut multiplier le nombre par 2 et, si le resultat est supérieur ou égal à 1, noter 1. Sinon noter 0. Puis recommencer en prenant la partie après la virgule : </p><table class="ml-5 example" data-v-2450ac13><tr data-v-2450ac13><td data-v-2450ac13>0,625</td><td data-v-2450ac13>× 2 =</td><td data-v-2450ac13><strong data-v-2450ac13>1</strong>,25</td><td data-v-2450ac13>→ 1</td></tr><tr data-v-2450ac13><td data-v-2450ac13>0,25</td><td data-v-2450ac13>× 2 =</td><td data-v-2450ac13><strong data-v-2450ac13>0</strong>,5</td><td data-v-2450ac13>→ 0</td></tr><tr data-v-2450ac13><td data-v-2450ac13>0,5</td><td data-v-2450ac13>× 2 =</td><td data-v-2450ac13><strong data-v-2450ac13>1</strong>,0</td><td data-v-2450ac13>→ 1</td></tr><tr data-v-2450ac13><td data-v-2450ac13></td></tr></table><p data-v-2450ac13><small data-v-2450ac13>(Se lit de haut en bas)</small><br data-v-2450ac13> 6,625<sub data-v-2450ac13>10</sub> = 110,101<sub data-v-2450ac13>2</sub></p><p data-v-2450ac13> Pour être précis à 100 %, il faut s&#39;arrêter lorsqu&#39;on obtient 1.0, comme ici. </p><p data-v-2450ac13> Attention cependant car certains nombres finis en décimal ne le sont pas forcément en binaire et inversement. À vous de voir où vous arrêter. </p><h2 data-v-2450ac13>La norme IEEE 754</h2><p data-v-2450ac13> C&#39;est la norme la plus utilisée pour stocker des nombres à virgules.<br data-v-2450ac13>Elle existe en précision simple (32 bits) et double (64 bits). </p><p data-v-2450ac13>Les nombres sont structurés comme suit :</p>',11),h={class:"ieee-754"},f=c(()=>t("div",{class:"bg-red-200 aspect-square"},"(S)",-1)),S=c(()=>t("div",{class:"col-span-8 col-start-2 bg-blue-200"},"Exposant",-1)),x=c(()=>t("div",{class:"col-start-10 col-span-full bg-lime-200"},"Mantisse",-1)),C=l('<ul data-v-2450ac13><li data-v-2450ac13>(S)igne :</li><ul data-v-2450ac13><li data-v-2450ac13>sur 1 bit</li><li data-v-2450ac13>0 si positif, 1 si négatif</li><li data-v-2450ac13>plus besoin de faire le complément à 2</li></ul><li data-v-2450ac13>Exposant :</li><ul data-v-2450ac13><li data-v-2450ac13>sur 8 bits</li><li data-v-2450ac13>127 est défini comme 0</li><li data-v-2450ac13>donc 126 = -1 et 128 = 1, etc.</li></ul><li data-v-2450ac13>Mantisse :</li><ul data-v-2450ac13><li data-v-2450ac13>sur 23 bits</li><li data-v-2450ac13> C&#39;est la valeur numérique du nombre, la virgule se situe avant le premier bit. </li><li data-v-2450ac13> Une valeur de 1 est supposée avant la virgule mais elle n&#39;est pas transmise car tous les nombres (sauf 0) contiennent au moins un 1. </li></ul></ul><h2 data-v-2450ac13>Calculer le signe</h2><p data-v-2450ac13> Simplement,<br data-v-2450ac13>Si le nombre est positif : mettre <strong data-v-2450ac13>0</strong><br data-v-2450ac13>Si le nombre est négatif : mettre 1 </p><p data-v-2450ac13>* On ne fait plus le complément à 2.</p><h2 data-v-2450ac13>Calculer l&#39;exposant</h2><p data-v-2450ac13> Si on prend le nombre 350,75<sub data-v-2450ac13>10</sub>, cela donne 1 0101 1110,11<sub data-v-2450ac13>2</sub></p><p data-v-2450ac13> L&#39;exposant est le nombre de crans dont on doit déplacer la virgule (vers la droite ou vers la gauche) pour arriver au premier 1. Ici, ça fait 8 (1<b data-v-2450ac13>,</b>0101 1110<span class="font-bold text-red-600" data-v-2450ac13>,</span>11) </p><p data-v-2450ac13> Si on la décale vers la gauche, on additionne, si on décale vers la droite, on soustrait. Le 127 est représenté comme étant 0. Donc ici on va faire 127 + 8 = 135 = <strong data-v-2450ac13>1000 0111</strong></p><h2 data-v-2450ac13>Calculer la mantisse</h2><p data-v-2450ac13> Reprenons 350,75<sub data-v-2450ac13>10</sub> qui vaut 1 0101 1110,11<sub data-v-2450ac13>2</sub> en binaire. Pour calculer la mantisse, on va juste enlever la virgule et le premier 1 : 0101 1110 11<br data-v-2450ac13>Puis, on complète avec des 0 afin de remplir les 23 bits : <strong data-v-2450ac13>010 1111 0110 0000 0000 0000</strong>. Nous avons notre mantisse. </p><p data-v-2450ac13> Il ne reste plus qu&#39;à tout appondre : <strong data-v-2450ac13>0100 0011 1010 1111 0110 0000 0000 0000</strong>. </p><h2 data-v-2450ac13>Cas particulier : le zéro</h2><p data-v-2450ac13> Pour écrire 0, on met simplement tous les bits à 0, soit : <strong data-v-2450ac13>0000 0000 0000 0000 0000 0000 0000 0000</strong></p><p data-v-2450ac13> * À savoir que 1000 0000 0000 0000 0000 0000 0000 0000 = -0 ce qui revient au même. </p>',14);function q(e,I){return s(),r("div",null,[_,t("div",h,[(s(),r(d,null,i(32,a=>t("div",{class:o(["aspect-square",{"bg-red-200":32-a==31,"bg-blue-200":32-a>=23&&32-a<=30,"bg-lime-200":32-a<23}])},[[0,22,23,30,31].includes(32-a)?(s(),r(d,{key:0},[v(u(32-a),1)],64)):p("",!0)],2)),64)),f,S,x]),C])}const P=n(g,[["render",q],["__scopeId","data-v-2450ac13"]]);export{P as default};
