import{_ as n,o as f,c as s,a as t,F as d,b as i,f as o,d as b,t as v,x as u,B as l,z as p,A as c}from"./index-7f407549.js";const m={},r=e=>(p("data-v-fffb6448"),e=e(),c(),e),g=l('<h2 data-v-fffb6448>Convertir un nombre réel en binaire.</h2><p data-v-fffb6448> Pour la partie entière, garder le même principe. Puis prendre la partie après la virgule. </p><p class="ml-5" data-v-fffb6448>6,625 → 0,625</p><p data-v-fffb6448> Il faut multiplier le nombre par 2 et, si le resultat est supérieur ou égal à 1, noter 1. Sinon noter 0. Puis recommencer en prenant la partie après la virgule : </p><table class="ml-5 example" data-v-fffb6448><tr data-v-fffb6448><td data-v-fffb6448>0,625</td><td data-v-fffb6448>× 2 =</td><td data-v-fffb6448><strong data-v-fffb6448>1</strong>,25</td><td data-v-fffb6448>→ 1</td></tr><tr data-v-fffb6448><td data-v-fffb6448>0,25</td><td data-v-fffb6448>× 2 =</td><td data-v-fffb6448><strong data-v-fffb6448>0</strong>,5</td><td data-v-fffb6448>→ 0</td></tr><tr data-v-fffb6448><td data-v-fffb6448>0,5</td><td data-v-fffb6448>× 2 =</td><td data-v-fffb6448><strong data-v-fffb6448>1</strong>,0</td><td data-v-fffb6448>→ 1</td></tr><tr data-v-fffb6448><td data-v-fffb6448></td></tr></table><p data-v-fffb6448><small data-v-fffb6448>(Se lit de haut en bas)</small><br data-v-fffb6448> 6,625<sub data-v-fffb6448>10</sub> = 110,101<sub data-v-fffb6448>2</sub></p><p data-v-fffb6448> Pour être précis à 100 %, il faut s&#39;arrêter lorsqu&#39;on obtient 1.0, comme ici. </p><p data-v-fffb6448> Attention cependant car certains nombres finis en décimal ne le sont pas forcément en binaire et inversement. À vous de voir où vous arrêter. </p><h2 data-v-fffb6448>La norme IEEE 754</h2><p data-v-fffb6448> C&#39;est la norme la plus utilisée pour stocker des nombres à virgules.<br data-v-fffb6448>Elle existe en précision simple (32 bits) et double (64 bits). </p><p data-v-fffb6448>Les nombres sont structurés comme suit :</p>',11),_={class:"ieee-754"},h=r(()=>t("div",{class:"bg-red-200 aspect-square"},"(S)",-1)),S=r(()=>t("div",{class:"col-span-8 col-start-2 bg-blue-200"},"Exposant",-1)),x=r(()=>t("div",{class:"col-start-10 col-span-full bg-lime-200"},"Mantisse",-1)),C=l('<ul data-v-fffb6448><li data-v-fffb6448>(S)igne :</li><ul data-v-fffb6448><li data-v-fffb6448>sur 1 bit</li><li data-v-fffb6448>0 si positif, 1 si négatif</li><li data-v-fffb6448>plus besoin de faire le complément à 2</li></ul><li data-v-fffb6448>Exposant :</li><ul data-v-fffb6448><li data-v-fffb6448>sur 8 bits</li><li data-v-fffb6448>127 est défini comme 0</li><li data-v-fffb6448>donc 126 = -1 et 128 = 1, etc.</li></ul><li data-v-fffb6448>Mantisse :</li><ul data-v-fffb6448><li data-v-fffb6448>sur 23 bits</li><li data-v-fffb6448> C&#39;est la valeur numérique du nombre, la virgule se situe avant le premier bit. </li><li data-v-fffb6448> Une valeur de 1 est supposée avant la virgule mais elle n&#39;est pas transmise car tous les nombres (sauf 0) contiennent au moins un 1. </li></ul></ul><h2 data-v-fffb6448>Calculer le signe</h2><p data-v-fffb6448> Simplement,<br data-v-fffb6448>Si le nombre est positif : mettre <strong data-v-fffb6448>0</strong><br data-v-fffb6448>Si le nombre est négatif : mettre 1 </p><p data-v-fffb6448>* On ne fait plus le complément à 2.</p><h2 data-v-fffb6448>Calculer l&#39;exposant</h2><p data-v-fffb6448> Si on prend le nombre 350,75<sub data-v-fffb6448>10</sub>, cela donne 1 0101 1110,11<sub data-v-fffb6448>2</sub></p><p data-v-fffb6448> L&#39;exposant est le nombre de crans dont on doit déplacer la virgule (vers la droite ou vers la gauche) pour arriver au premier 1. Ici, ça fait 8 (1<b data-v-fffb6448>,</b>0101 1110<span class="font-bold text-red-600" data-v-fffb6448>,</span>11) </p><p data-v-fffb6448> Si on la décale vers la gauche, on additionne, si on décale vers la droite, on soustrait. Le 127 est représenté comme étant 0. Donc ici on va faire 127 + 8 = 135 = <strong data-v-fffb6448>1000 0111</strong></p><h2 data-v-fffb6448>Calculer la mantisse</h2><p data-v-fffb6448> Reprenons 350,75<sub data-v-fffb6448>10</sub> qui vaut 1 0101 1110,11<sub data-v-fffb6448>2</sub> en binaire. Pour calculer la mantisse, on va juste enlever la virgule et le premier 1 : 0101 1110 11<br data-v-fffb6448>Puis, on complète avec des 0 afin de remplir les 23 bits : <strong data-v-fffb6448>010 1111 0110 0000 0000 0000</strong>. Nous avons notre mantisse. </p><p data-v-fffb6448> Il ne reste plus qu&#39;à tout appondre : <strong data-v-fffb6448>0100 0011 1010 1111 0110 0000 0000 0000</strong>. </p><h2 data-v-fffb6448>Cas particulier : le zéro</h2><p data-v-fffb6448> Pour écrire 0, on met simplement tous les bits à 0, soit : <strong data-v-fffb6448>0000 0000 0000 0000 0000 0000 0000 0000</strong></p><p data-v-fffb6448> * À savoir que 1000 0000 0000 0000 0000 0000 0000 0000 = -0 ce qui revient au même. </p>',14);function q(e,I){return f(),s("div",null,[g,t("div",_,[(f(),s(d,null,i(32,a=>t("div",{class:o(["aspect-square",{"bg-red-200":32-a==31,"bg-blue-200":32-a>=23&&32-a<=30,"bg-lime-200":32-a<23}])},[[0,22,23,30,31].includes(32-a)?(f(),s(d,{key:0},[b(v(32-a),1)],64)):u("",!0)],2)),64)),h,S,x]),C])}const P=n(m,[["render",q],["__scopeId","data-v-fffb6448"]]);export{P as default};
